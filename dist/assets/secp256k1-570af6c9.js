import{b6 as xe,b7 as Mt,b8 as Nt,b9 as pe,ba as Ee,bb as Ye,bc as Rt,bd as De,be as $,bf as Ge,bg as We,bh as $e,bi as ve}from"./index-e2bdff38.js";function Xe(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const i=BigInt(32),o=BigInt(4294967295),c=Number(e>>i&o),f=Number(e&o),s=r?4:0,a=r?0:4;t.setUint32(n+s,c,r),t.setUint32(n+a,f,r)}function Qe(t,n,e){return t&n^~t&e}function Je(t,n,e){return t&n^t&e^n&e}class Fe extends xe{constructor(n,e,r,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=i,this.buffer=new Uint8Array(n),this.view=Mt(this.buffer)}update(n){Nt(this),n=pe(n),Ee(n);const{view:e,buffer:r,blockLen:i}=this,o=n.length;for(let c=0;c<o;){const f=Math.min(i-this.pos,o-c);if(f===i){const s=Mt(n);for(;i<=o-c;c+=i)this.process(s,c);continue}r.set(n.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===i&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){Nt(this),Ye(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:i,isLE:o}=this;let{pos:c}=this;e[c++]=128,Rt(this.buffer.subarray(c)),this.padOffset>i-c&&(this.process(r,0),c=0);for(let l=c;l<i;l++)e[l]=0;Xe(r,i-8,BigInt(this.length*8),o),this.process(r,0);const f=Mt(n),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=s/4,d=this.get();if(a>d.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)f.setUint32(4*l,d[l],o)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:i,finished:o,destroyed:c,pos:f}=this;return n.destroyed=c,n.finished=o,n.length=i,n.pos=f,i%e&&n.buffer.set(r),n}clone(){return this._cloneInto()}}const et=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),tn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),nt=new Uint32Array(64);class en extends Fe{constructor(n=32){super(64,n,8,!1),this.A=et[0]|0,this.B=et[1]|0,this.C=et[2]|0,this.D=et[3]|0,this.E=et[4]|0,this.F=et[5]|0,this.G=et[6]|0,this.H=et[7]|0}get(){const{A:n,B:e,C:r,D:i,E:o,F:c,G:f,H:s}=this;return[n,e,r,i,o,c,f,s]}set(n,e,r,i,o,c,f,s){this.A=n|0,this.B=e|0,this.C=r|0,this.D=i|0,this.E=o|0,this.F=c|0,this.G=f|0,this.H=s|0}process(n,e){for(let l=0;l<16;l++,e+=4)nt[l]=n.getUint32(e,!1);for(let l=16;l<64;l++){const x=nt[l-15],m=nt[l-2],_=$(x,7)^$(x,18)^x>>>3,g=$(m,17)^$(m,19)^m>>>10;nt[l]=g+nt[l-7]+_+nt[l-16]|0}let{A:r,B:i,C:o,D:c,E:f,F:s,G:a,H:d}=this;for(let l=0;l<64;l++){const x=$(f,6)^$(f,11)^$(f,25),m=d+x+Qe(f,s,a)+tn[l]+nt[l]|0,g=($(r,2)^$(r,13)^$(r,22))+Je(r,i,o)|0;d=a,a=s,s=f,f=c+m|0,c=o,o=i,i=r,r=m+g|0}r=r+this.A|0,i=i+this.B|0,o=o+this.C|0,c=c+this.D|0,f=f+this.E|0,s=s+this.F|0,a=a+this.G|0,d=d+this.H|0,this.set(r,i,o,c,f,s,a,d)}roundClean(){Rt(nt)}destroy(){this.set(0,0,0,0,0,0,0,0),Rt(this.buffer)}}const Ut=De(()=>new en);class Be extends xe{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Ge(n);const r=pe(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,o=new Uint8Array(i);o.set(r.length>i?n.create().update(r).digest():r);for(let c=0;c<o.length;c++)o[c]^=54;this.iHash.update(o),this.oHash=n.create();for(let c=0;c<o.length;c++)o[c]^=106;this.oHash.update(o),Rt(o)}update(n){return Nt(this),this.iHash.update(n),this}digestInto(n){Nt(this),Ee(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:i,destroyed:o,blockLen:c,outputLen:f}=this;return n=n,n.finished=i,n.destroyed=o,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Se=(t,n,e)=>new Be(t,n).update(e).digest();Se.create=(t,n)=>new Be(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const re=BigInt(0),Qt=BigInt(1);function _t(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function st(t){if(!_t(t))throw new Error("Uint8Array expected")}function pt(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}function qt(t){const n=t.toString(16);return n.length&1?"0"+n:n}function Ae(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?re:BigInt("0x"+t)}const _e=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",nn=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function Et(t){if(st(t),_e)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=nn[t[e]];return n}const J={_0:48,_9:57,A:65,F:70,a:97,f:102};function ae(t){if(t>=J._0&&t<=J._9)return t-J._0;if(t>=J.A&&t<=J.F)return t-(J.A-10);if(t>=J.a&&t<=J.f)return t-(J.a-10)}function Ht(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(_e)return Uint8Array.fromHex(t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let i=0,o=0;i<e;i++,o+=2){const c=ae(t.charCodeAt(o)),f=ae(t.charCodeAt(o+1));if(c===void 0||f===void 0){const s=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+o)}r[i]=c*16+f}return r}function X(t){return Ae(Et(t))}function Ie(t){return st(t),Ae(Et(Uint8Array.from(t).reverse()))}function lt(t,n){return Ht(t.toString(16).padStart(n*2,"0"))}function Oe(t,n){return lt(t,n).reverse()}function z(t,n,e){let r;if(typeof n=="string")try{r=Ht(n)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else if(_t(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const i=r.length;if(typeof e=="number"&&i!==e)throw new Error(t+" of length "+e+" expected, got "+i);return r}function D(...t){let n=0;for(let r=0;r<t.length;r++){const i=t[r];st(i),n+=i.length}const e=new Uint8Array(n);for(let r=0,i=0;r<t.length;r++){const o=t[r];e.set(o,i),i+=o.length}return e}function oe(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const jt=t=>typeof t=="bigint"&&re<=t;function vt(t,n,e){return jt(t)&&jt(n)&&jt(e)&&n<=t&&t<e}function ut(t,n,e,r){if(!vt(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function rn(t){let n;for(n=0;t>re;t>>=Qt,n+=1);return n}const Ct=t=>(Qt<<BigInt(t))-Qt,Kt=t=>new Uint8Array(t),ue=t=>Uint8Array.from(t);function on(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Kt(t),i=Kt(t),o=0;const c=()=>{r.fill(1),i.fill(0),o=0},f=(...l)=>e(i,r,...l),s=(l=Kt(0))=>{i=f(ue([0]),l),r=f(),l.length!==0&&(i=f(ue([1]),l),r=f())},a=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const x=[];for(;l<n;){r=f();const m=r.slice();x.push(m),l+=r.length}return D(...x)};return(l,x)=>{c(),s(l);let m;for(;!(m=x(a()));)s();return c(),m}}const sn={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||_t(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function It(t,n,e={}){const r=(i,o,c)=>{const f=sn[o];if(typeof f!="function")throw new Error("invalid validator function");const s=t[i];if(!(c&&s===void 0)&&!f(s,t))throw new Error("param "+String(i)+" is invalid. Expected "+o+", got "+s)};for(const[i,o]of Object.entries(n))r(i,o,!1);for(const[i,o]of Object.entries(e))r(i,o,!0);return t}function le(t){const n=new WeakMap;return(e,...r)=>{const i=n.get(e);if(i!==void 0)return i;const o=t(e,...r);return n.set(e,o),o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const K=BigInt(0),M=BigInt(1),at=BigInt(2),cn=BigInt(3),qe=BigInt(4),Ne=BigInt(5),Re=BigInt(8);function Z(t,n){const e=t%n;return e>=K?e:n+e}function Y(t,n,e){let r=t;for(;n-- >K;)r*=r,r%=e;return r}function Jt(t,n){if(t===K)throw new Error("invert: expected non-zero number");if(n<=K)throw new Error("invert: expected positive modulus, got "+n);let e=Z(t,n),r=n,i=K,o=M;for(;e!==K;){const f=r/e,s=r%e,a=i-o*f;r=e,e=s,i=o,o=a}if(r!==M)throw new Error("invert: does not exist");return Z(i,n)}function Ue(t,n){const e=(t.ORDER+M)/qe,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function fn(t,n){const e=(t.ORDER-Ne)/Re,r=t.mul(n,at),i=t.pow(r,e),o=t.mul(n,i),c=t.mul(t.mul(o,at),i),f=t.mul(o,t.sub(c,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}function an(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-M,e=0;for(;n%at===K;)n/=at,e++;let r=at;const i=se(t);for(;de(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return Ue;let o=i.pow(r,n);const c=(n+M)/at;return function(s,a){if(s.is0(a))return a;if(de(s,a)!==1)throw new Error("Cannot find square root");let d=e,l=s.mul(s.ONE,o),x=s.pow(a,n),m=s.pow(a,c);for(;!s.eql(x,s.ONE);){if(s.is0(x))return s.ZERO;let _=1,g=s.sqr(x);for(;!s.eql(g,s.ONE);)if(_++,g=s.sqr(g),_===d)throw new Error("Cannot find square root");const T=M<<BigInt(d-_-1),I=s.pow(l,T);d=_,l=s.sqr(I),x=s.mul(x,l),m=s.mul(m,I)}return m}}function un(t){return t%qe===cn?Ue:t%Re===Ne?fn:an(t)}const ln=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function He(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=ln.reduce((r,i)=>(r[i]="function",r),n);return It(t,e)}function dn(t,n,e){if(e<K)throw new Error("invalid exponent, negatives unsupported");if(e===K)return t.ONE;if(e===M)return n;let r=t.ONE,i=n;for(;e>K;)e&M&&(r=t.mul(r,i)),i=t.sqr(i),e>>=M;return r}function Zt(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),i=n.reduce((c,f,s)=>t.is0(f)?c:(r[s]=c,t.mul(c,f)),t.ONE),o=t.inv(i);return n.reduceRight((c,f,s)=>t.is0(f)?c:(r[s]=t.mul(c,r[s]),t.mul(c,f)),o),r}function de(t,n){const e=(t.ORDER-M)/at,r=t.pow(n,e),i=t.eql(r,t.ONE),o=t.eql(r,t.ZERO),c=t.eql(r,t.neg(t.ONE));if(!i&&!o&&!c)throw new Error("invalid Legendre symbol result");return i?1:o?0:-1}function Le(t,n){n!==void 0&&We(n);const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function se(t,n,e=!1,r={}){if(t<=K)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:i,nByteLength:o}=Le(t,n);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,isLE:e,BITS:i,BYTES:o,MASK:Ct(i),ZERO:K,ONE:M,create:s=>Z(s,t),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return K<=s&&s<t},is0:s=>s===K,isOdd:s=>(s&M)===M,neg:s=>Z(-s,t),eql:(s,a)=>s===a,sqr:s=>Z(s*s,t),add:(s,a)=>Z(s+a,t),sub:(s,a)=>Z(s-a,t),mul:(s,a)=>Z(s*a,t),pow:(s,a)=>dn(f,s,a),div:(s,a)=>Z(s*Jt(a,t),t),sqrN:s=>s*s,addN:(s,a)=>s+a,subN:(s,a)=>s-a,mulN:(s,a)=>s*a,inv:s=>Jt(s,t),sqrt:r.sqrt||(s=>(c||(c=un(t)),c(f,s))),toBytes:s=>e?Oe(s,o):lt(s,o),fromBytes:s=>{if(s.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+s.length);return e?Ie(s):X(s)},invertBatch:s=>Zt(f,s),cmov:(s,a,d)=>d?a:s});return Object.freeze(f)}function Te(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function ke(t){const n=Te(t);return n+Math.ceil(n/2)}function hn(t,n,e=!1){const r=t.length,i=Te(n),o=ke(n);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const c=e?Ie(t):X(t),f=Z(c,n-M)+M;return e?Oe(f,i):lt(f,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const he=BigInt(0),Ft=BigInt(1);function Yt(t,n){const e=n.negate();return t?e:n}function Ce(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Dt(t,n){Ce(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1),i=2**t,o=Ct(t),c=BigInt(t);return{windows:e,windowSize:r,mask:o,maxNumber:i,shiftBy:c}}function we(t,n,e){const{windowSize:r,mask:i,maxNumber:o,shiftBy:c}=e;let f=Number(t&i),s=t>>c;f>r&&(f-=o,s+=Ft);const a=n*r,d=a+Math.abs(f)-1,l=f===0,x=f<0,m=n%2!==0;return{nextN:s,offset:d,isZero:l,isNeg:x,isNegF:m,offsetF:a}}function wn(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function gn(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Gt=new WeakMap,Ze=new WeakMap;function Wt(t){return Ze.get(t)||1}function bn(t,n){return{constTimeNegate:Yt,hasPrecomputes(e){return Wt(e)!==1},unsafeLadder(e,r,i=t.ZERO){let o=e;for(;r>he;)r&Ft&&(i=i.add(o)),o=o.double(),r>>=Ft;return i},precomputeWindow(e,r){const{windows:i,windowSize:o}=Dt(r,n),c=[];let f=e,s=f;for(let a=0;a<i;a++){s=f,c.push(s);for(let d=1;d<o;d++)s=s.add(f),c.push(s);f=s.double()}return c},wNAF(e,r,i){let o=t.ZERO,c=t.BASE;const f=Dt(e,n);for(let s=0;s<f.windows;s++){const{nextN:a,offset:d,isZero:l,isNeg:x,isNegF:m,offsetF:_}=we(i,s,f);i=a,l?c=c.add(Yt(m,r[_])):o=o.add(Yt(x,r[d]))}return{p:o,f:c}},wNAFUnsafe(e,r,i,o=t.ZERO){const c=Dt(e,n);for(let f=0;f<c.windows&&i!==he;f++){const{nextN:s,offset:a,isZero:d,isNeg:l}=we(i,f,c);if(i=s,!d){const x=r[a];o=o.add(l?x.negate():x)}}return o},getPrecomputes(e,r,i){let o=Gt.get(r);return o||(o=this.precomputeWindow(r,e),e!==1&&Gt.set(r,i(o))),o},wNAFCached(e,r,i){const o=Wt(e);return this.wNAF(o,this.getPrecomputes(o,e,i),r)},wNAFCachedUnsafe(e,r,i,o){const c=Wt(e);return c===1?this.unsafeLadder(e,r,o):this.wNAFUnsafe(c,this.getPrecomputes(c,e,i),r,o)},setWindowSize(e,r){Ce(r,n),Ze.set(e,r),Gt.delete(e)}}}function mn(t,n,e,r){wn(e,t),gn(r,n);const i=e.length,o=r.length;if(i!==o)throw new Error("arrays of points and scalars must have equal length");const c=t.ZERO,f=rn(BigInt(i));let s=1;f>12?s=f-3:f>4?s=f-2:f>0&&(s=2);const a=Ct(s),d=new Array(Number(a)+1).fill(c),l=Math.floor((n.BITS-1)/s)*s;let x=c;for(let m=l;m>=0;m-=s){d.fill(c);for(let g=0;g<o;g++){const T=r[g],I=Number(T>>BigInt(m)&a);d[I]=d[I].add(e[g])}let _=c;for(let g=d.length-1,T=c;g>0;g--)T=T.add(d[g]),_=_.add(T);if(x=x.add(_),m!==0)for(let g=0;g<s;g++)x=x.double()}return x}function ze(t){return He(t.Fp),It(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Le(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ge(t){t.lowS!==void 0&&pt("lowS",t.lowS),t.prehash!==void 0&&pt("prehash",t.prehash)}function yn(t){const n=ze(t);It(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:e,Fp:r,a:i}=n;if(e){if(!r.eql(i,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}class xn extends Error{constructor(n=""){super(n)}}const F={Err:xn,_tlv:{encode:(t,n)=>{const{Err:e}=F;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,i=qt(r);if(i.length/2&128)throw new e("tlv.encode: long form length too big");const o=r>127?qt(i.length/2|128):"";return qt(t)+o+i+n},decode(t,n){const{Err:e}=F;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const i=n[r++],o=!!(i&128);let c=0;if(!o)c=i;else{const s=i&127;if(!s)throw new e("tlv.decode(long): indefinite length not supported");if(s>4)throw new e("tlv.decode(long): byte length is too big");const a=n.subarray(r,r+s);if(a.length!==s)throw new e("tlv.decode: length bytes not complete");if(a[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const d of a)c=c<<8|d;if(r+=s,c<128)throw new e("tlv.decode(long): not minimal encoding")}const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=F;if(t<W)throw new n("integer: negative integers are not allowed");let e=qt(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=F;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return X(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=F,i=z("signature",t),{v:o,l:c}=r.decode(48,i);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:s}=r.decode(2,o),{v:a,l:d}=r.decode(2,s);if(d.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(a)}},hexFromSig(t){const{_tlv:n,_int:e}=F,r=n.encode(2,e.encode(t.r)),i=n.encode(2,e.encode(t.s)),o=r+i;return n.encode(48,o)}};function $t(t,n){return Et(lt(t,n))}const W=BigInt(0),k=BigInt(1),rt=BigInt(2),xt=BigInt(3),te=BigInt(4);function pn(t){const n=yn(t),{Fp:e}=n,r=se(n.n,n.nBitLength),i=n.toBytes||((y,u,b)=>{const p=u.toAffine();return D(Uint8Array.from([4]),e.toBytes(p.x),e.toBytes(p.y))}),o=n.fromBytes||(y=>{const u=y.subarray(1),b=e.fromBytes(u.subarray(0,e.BYTES)),p=e.fromBytes(u.subarray(e.BYTES,2*e.BYTES));return{x:b,y:p}});function c(y){const{a:u,b}=n,p=e.sqr(y),v=e.mul(p,y);return e.add(e.add(v,e.mul(y,u)),b)}function f(y,u){const b=e.sqr(u),p=c(y);return e.eql(b,p)}if(!f(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const s=e.mul(e.pow(n.a,xt),te),a=e.mul(e.sqr(n.b),BigInt(27));if(e.is0(e.add(s,a)))throw new Error("bad curve params: a or b");function d(y){return vt(y,k,n.n)}function l(y){const{allowedPrivateKeyLengths:u,nByteLength:b,wrapPrivateKey:p,n:v}=n;if(u&&typeof y!="bigint"){if(_t(y)&&(y=Et(y)),typeof y!="string"||!u.includes(y.length))throw new Error("invalid private key");y=y.padStart(b*2,"0")}let O;try{O=typeof y=="bigint"?y:X(z("private key",y,b))}catch{throw new Error("invalid private key, expected hex or "+b+" bytes, got "+typeof y)}return p&&(O=Z(O,v)),ut("private key",O,k,v),O}function x(y){if(!(y instanceof g))throw new Error("ProjectivePoint expected")}const m=le((y,u)=>{const{px:b,py:p,pz:v}=y;if(e.eql(v,e.ONE))return{x:b,y:p};const O=y.is0();u==null&&(u=O?e.ONE:e.inv(v));const H=e.mul(b,u),L=e.mul(p,u),B=e.mul(v,u);if(O)return{x:e.ZERO,y:e.ZERO};if(!e.eql(B,e.ONE))throw new Error("invZ was invalid");return{x:H,y:L}}),_=le(y=>{if(y.is0()){if(n.allowInfinityPoint&&!e.is0(y.py))return;throw new Error("bad point: ZERO")}const{x:u,y:b}=y.toAffine();if(!e.isValid(u)||!e.isValid(b))throw new Error("bad point: x or y not FE");if(!f(u,b))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(u,b,p){if(u==null||!e.isValid(u))throw new Error("x required");if(b==null||!e.isValid(b)||e.is0(b))throw new Error("y required");if(p==null||!e.isValid(p))throw new Error("z required");this.px=u,this.py=b,this.pz=p,Object.freeze(this)}static fromAffine(u){const{x:b,y:p}=u||{};if(!u||!e.isValid(b)||!e.isValid(p))throw new Error("invalid affine point");if(u instanceof g)throw new Error("projective point not allowed");const v=O=>e.eql(O,e.ZERO);return v(b)&&v(p)?g.ZERO:new g(b,p,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const b=Zt(e,u.map(p=>p.pz));return u.map((p,v)=>p.toAffine(b[v])).map(g.fromAffine)}static fromHex(u){const b=g.fromAffine(o(z("pointHex",u)));return b.assertValidity(),b}static fromPrivateKey(u){return g.BASE.multiply(l(u))}static msm(u,b){return mn(g,r,u,b)}_setWindowSize(u){U.setWindowSize(this,u)}assertValidity(){_(this)}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){x(u);const{px:b,py:p,pz:v}=this,{px:O,py:H,pz:L}=u,B=e.eql(e.mul(b,L),e.mul(O,v)),R=e.eql(e.mul(p,L),e.mul(H,v));return B&&R}negate(){return new g(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b}=n,p=e.mul(b,xt),{px:v,py:O,pz:H}=this;let L=e.ZERO,B=e.ZERO,R=e.ZERO,S=e.mul(v,v),V=e.mul(O,O),w=e.mul(H,H),h=e.mul(v,O);return h=e.add(h,h),R=e.mul(v,H),R=e.add(R,R),L=e.mul(u,R),B=e.mul(p,w),B=e.add(L,B),L=e.sub(V,B),B=e.add(V,B),B=e.mul(L,B),L=e.mul(h,L),R=e.mul(p,R),w=e.mul(u,w),h=e.sub(S,w),h=e.mul(u,h),h=e.add(h,R),R=e.add(S,S),S=e.add(R,S),S=e.add(S,w),S=e.mul(S,h),B=e.add(B,S),w=e.mul(O,H),w=e.add(w,w),S=e.mul(w,h),L=e.sub(L,S),R=e.mul(w,V),R=e.add(R,R),R=e.add(R,R),new g(L,B,R)}add(u){x(u);const{px:b,py:p,pz:v}=this,{px:O,py:H,pz:L}=u;let B=e.ZERO,R=e.ZERO,S=e.ZERO;const V=n.a,w=e.mul(n.b,xt);let h=e.mul(b,O),E=e.mul(p,H),N=e.mul(v,L),A=e.add(b,p),q=e.add(O,H);A=e.mul(A,q),q=e.add(h,E),A=e.sub(A,q),q=e.add(b,v);let C=e.add(O,L);return q=e.mul(q,C),C=e.add(h,N),q=e.sub(q,C),C=e.add(p,v),B=e.add(H,L),C=e.mul(C,B),B=e.add(E,N),C=e.sub(C,B),S=e.mul(V,q),B=e.mul(w,N),S=e.add(B,S),B=e.sub(E,S),S=e.add(E,S),R=e.mul(B,S),E=e.add(h,h),E=e.add(E,h),N=e.mul(V,N),q=e.mul(w,q),E=e.add(E,N),N=e.sub(h,N),N=e.mul(V,N),q=e.add(q,N),h=e.mul(E,q),R=e.add(R,h),h=e.mul(C,q),B=e.mul(A,B),B=e.sub(B,h),h=e.mul(A,E),S=e.mul(C,S),S=e.add(S,h),new g(B,R,S)}subtract(u){return this.add(u.negate())}is0(){return this.equals(g.ZERO)}wNAF(u){return U.wNAFCached(this,u,g.normalizeZ)}multiplyUnsafe(u){const{endo:b,n:p}=n;ut("scalar",u,W,p);const v=g.ZERO;if(u===W)return v;if(this.is0()||u===k)return this;if(!b||U.hasPrecomputes(this))return U.wNAFCachedUnsafe(this,u,g.normalizeZ);let{k1neg:O,k1:H,k2neg:L,k2:B}=b.splitScalar(u),R=v,S=v,V=this;for(;H>W||B>W;)H&k&&(R=R.add(V)),B&k&&(S=S.add(V)),V=V.double(),H>>=k,B>>=k;return O&&(R=R.negate()),L&&(S=S.negate()),S=new g(e.mul(S.px,b.beta),S.py,S.pz),R.add(S)}multiply(u){const{endo:b,n:p}=n;ut("scalar",u,k,p);let v,O;if(b){const{k1neg:H,k1:L,k2neg:B,k2:R}=b.splitScalar(u);let{p:S,f:V}=this.wNAF(L),{p:w,f:h}=this.wNAF(R);S=U.constTimeNegate(H,S),w=U.constTimeNegate(B,w),w=new g(e.mul(w.px,b.beta),w.py,w.pz),v=S.add(w),O=V.add(h)}else{const{p:H,f:L}=this.wNAF(u);v=H,O=L}return g.normalizeZ([v,O])[0]}multiplyAndAddUnsafe(u,b,p){const v=g.BASE,O=(L,B)=>B===W||B===k||!L.equals(v)?L.multiplyUnsafe(B):L.multiply(B),H=O(this,b).add(O(u,p));return H.is0()?void 0:H}toAffine(u){return m(this,u)}isTorsionFree(){const{h:u,isTorsionFree:b}=n;if(u===k)return!0;if(b)return b(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:b}=n;return u===k?this:b?b(g,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return pt("isCompressed",u),this.assertValidity(),i(g,this,u)}toHex(u=!0){return pt("isCompressed",u),Et(this.toRawBytes(u))}}g.BASE=new g(n.Gx,n.Gy,e.ONE),g.ZERO=new g(e.ZERO,e.ONE,e.ZERO);const{endo:T,nBitLength:I}=n,U=bn(g,T?Math.ceil(I/2):I);return{CURVE:n,ProjectivePoint:g,normPrivateKeyToScalar:l,weierstrassEquation:c,isWithinCurveOrder:d}}function En(t){const n=ze(t);return It(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function vn(t){const n=En(t),{Fp:e,n:r,nByteLength:i,nBitLength:o}=n,c=e.BYTES+1,f=2*e.BYTES+1;function s(w){return Z(w,r)}function a(w){return Jt(w,r)}const{ProjectivePoint:d,normPrivateKeyToScalar:l,weierstrassEquation:x,isWithinCurveOrder:m}=pn({...n,toBytes(w,h,E){const N=h.toAffine(),A=e.toBytes(N.x),q=D;return pt("isCompressed",E),E?q(Uint8Array.from([h.hasEvenY()?2:3]),A):q(Uint8Array.from([4]),A,e.toBytes(N.y))},fromBytes(w){const h=w.length,E=w[0],N=w.subarray(1);if(h===c&&(E===2||E===3)){const A=X(N);if(!vt(A,k,e.ORDER))throw new Error("Point is not on curve");const q=x(A);let C;try{C=e.sqrt(q)}catch(G){const j=G instanceof Error?": "+G.message:"";throw new Error("Point is not on curve"+j)}const P=(C&k)===k;return(E&1)===1!==P&&(C=e.neg(C)),{x:A,y:C}}else if(h===f&&E===4){const A=e.fromBytes(N.subarray(0,e.BYTES)),q=e.fromBytes(N.subarray(e.BYTES,2*e.BYTES));return{x:A,y:q}}else{const A=c,q=f;throw new Error("invalid Point, expected length of "+A+", or uncompressed "+q+", got "+h)}}});function _(w){const h=r>>k;return w>h}function g(w){return _(w)?s(-w):w}const T=(w,h,E)=>X(w.slice(h,E));class I{constructor(h,E,N){ut("r",h,k,r),ut("s",E,k,r),this.r=h,this.s=E,N!=null&&(this.recovery=N),Object.freeze(this)}static fromCompact(h){const E=i;return h=z("compactSignature",h,E*2),new I(T(h,0,E),T(h,E,2*E))}static fromDER(h){const{r:E,s:N}=F.toSig(z("DER",h));return new I(E,N)}assertValidity(){}addRecoveryBit(h){return new I(this.r,this.s,h)}recoverPublicKey(h){const{r:E,s:N,recovery:A}=this,q=v(z("msgHash",h));if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");const C=A===2||A===3?E+n.n:E;if(C>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const P=A&1?"03":"02",Q=d.fromHex(P+$t(C,e.BYTES)),G=a(C),j=s(-q*G),dt=s(N*G),tt=d.BASE.multiplyAndAddUnsafe(Q,j,dt);if(!tt)throw new Error("point at infinify");return tt.assertValidity(),tt}hasHighS(){return _(this.s)}normalizeS(){return this.hasHighS()?new I(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return Ht(this.toDERHex())}toDERHex(){return F.hexFromSig(this)}toCompactRawBytes(){return Ht(this.toCompactHex())}toCompactHex(){const h=i;return $t(this.r,h)+$t(this.s,h)}}const U={isValidPrivateKey(w){try{return l(w),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const w=ke(n.n);return hn(n.randomBytes(w),n.n)},precompute(w=8,h=d.BASE){return h._setWindowSize(w),h.multiply(BigInt(3)),h}};function y(w,h=!0){return d.fromPrivateKey(w).toRawBytes(h)}function u(w){if(typeof w=="bigint")return!1;if(w instanceof d)return!0;const E=z("key",w).length,N=e.BYTES,A=N+1,q=2*N+1;if(!(n.allowedPrivateKeyLengths||i===A))return E===A||E===q}function b(w,h,E=!0){if(u(w)===!0)throw new Error("first arg must be private key");if(u(h)===!1)throw new Error("second arg must be public key");return d.fromHex(h).multiply(l(w)).toRawBytes(E)}const p=n.bits2int||function(w){if(w.length>8192)throw new Error("input is too large");const h=X(w),E=w.length*8-o;return E>0?h>>BigInt(E):h},v=n.bits2int_modN||function(w){return s(p(w))},O=Ct(o);function H(w){return ut("num < 2^"+o,w,W,O),lt(w,i)}function L(w,h,E=B){if(["recovered","canonical"].some(ct=>ct in E))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:A}=n;let{lowS:q,prehash:C,extraEntropy:P}=E;q==null&&(q=!0),w=z("msgHash",w),ge(E),C&&(w=z("prehashed msgHash",N(w)));const Q=v(w),G=l(h),j=[H(G),H(Q)];if(P!=null&&P!==!1){const ct=P===!0?A(e.BYTES):P;j.push(z("extraEntropy",ct))}const dt=D(...j),tt=Q;function Vt(ct){const ht=p(ct);if(!m(ht))return;const Pt=a(ht),bt=d.BASE.multiply(ht).toAffine(),ft=s(bt.x);if(ft===W)return;const mt=s(Pt*s(tt+ft*G));if(mt===W)return;let yt=(bt.x===ft?0:2)|Number(bt.y&k),wt=mt;return q&&_(mt)&&(wt=g(mt),yt^=1),new I(ft,wt,yt)}return{seed:dt,k2sig:Vt}}const B={lowS:n.lowS,prehash:!1},R={lowS:n.lowS,prehash:!1};function S(w,h,E=B){const{seed:N,k2sig:A}=L(w,h,E),q=n;return on(q.hash.outputLen,q.nByteLength,q.hmac)(N,A)}d.BASE._setWindowSize(8);function V(w,h,E,N=R){var yt;const A=w;h=z("msgHash",h),E=z("publicKey",E);const{lowS:q,prehash:C,format:P}=N;if(ge(N),"strict"in N)throw new Error("options.strict was renamed to lowS");if(P!==void 0&&P!=="compact"&&P!=="der")throw new Error("format must be compact or der");const Q=typeof A=="string"||_t(A),G=!Q&&!P&&typeof A=="object"&&A!==null&&typeof A.r=="bigint"&&typeof A.s=="bigint";if(!Q&&!G)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let j,dt;try{if(G&&(j=new I(A.r,A.s)),Q){try{P!=="compact"&&(j=I.fromDER(A))}catch(wt){if(!(wt instanceof F.Err))throw wt}!j&&P!=="der"&&(j=I.fromCompact(A))}dt=d.fromHex(E)}catch{return!1}if(!j||q&&j.hasHighS())return!1;C&&(h=n.hash(h));const{r:tt,s:Vt}=j,ct=v(h),ht=a(Vt),Pt=s(ct*ht),bt=s(tt*ht),ft=(yt=d.BASE.multiplyAndAddUnsafe(dt,Pt,bt))==null?void 0:yt.toAffine();return ft?s(ft.x)===tt:!1}return{CURVE:n,getPublicKey:y,getSharedSecret:b,sign:S,verify:V,ProjectivePoint:d,Signature:I,utils:U}}function Bn(t,n){const e=t.ORDER;let r=W;for(let _=e-k;_%rt===W;_/=rt)r+=k;const i=r,o=rt<<i-k-k,c=o*rt,f=(e-k)/c,s=(f-k)/rt,a=c-k,d=o,l=t.pow(n,f),x=t.pow(n,(f+k)/rt);let m=(_,g)=>{let T=l,I=t.pow(g,a),U=t.sqr(I);U=t.mul(U,g);let y=t.mul(_,U);y=t.pow(y,s),y=t.mul(y,I),I=t.mul(y,g),U=t.mul(y,_);let u=t.mul(U,I);y=t.pow(u,d);let b=t.eql(y,t.ONE);I=t.mul(U,x),y=t.mul(u,T),U=t.cmov(I,U,b),u=t.cmov(y,u,b);for(let p=i;p>k;p--){let v=p-rt;v=rt<<v-k;let O=t.pow(u,v);const H=t.eql(O,t.ONE);I=t.mul(U,T),T=t.mul(T,T),O=t.mul(u,T),U=t.cmov(I,U,H),u=t.cmov(O,u,H)}return{isValid:b,value:U}};if(t.ORDER%te===xt){const _=(t.ORDER-xt)/te,g=t.sqrt(t.neg(n));m=(T,I)=>{let U=t.sqr(I);const y=t.mul(T,I);U=t.mul(U,y);let u=t.pow(U,_);u=t.mul(u,y);const b=t.mul(u,g),p=t.mul(t.sqr(u),I),v=t.eql(p,T);let O=t.cmov(b,u,v);return{isValid:v,value:O}}}return m}function Sn(t,n){if(He(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=Bn(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let i,o,c,f,s,a,d,l;i=t.sqr(r),i=t.mul(i,n.Z),o=t.sqr(i),o=t.add(o,i),c=t.add(o,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(o),!t.eql(o,t.ZERO)),f=t.mul(f,n.A),o=t.sqr(c),a=t.sqr(f),s=t.mul(a,n.A),o=t.add(o,s),o=t.mul(o,c),a=t.mul(a,f),s=t.mul(a,n.B),o=t.add(o,s),d=t.mul(i,c);const{isValid:x,value:m}=e(o,a);l=t.mul(i,r),l=t.mul(l,m),d=t.cmov(d,c,x),l=t.cmov(l,m,x);const _=t.isOdd(r)===t.isOdd(l);l=t.cmov(t.neg(l),l,_);const g=Zt(t,[f],!0)[0];return d=t.mul(d,g),{x:d,y:l}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function An(t){return{hash:t,hmac:(n,...e)=>Se(t,n,$e(...e)),randomBytes:ve}}function _n(t,n){const e=r=>vn({...t,...An(r)});return{...e(n),create:e}}const In=X;function ot(t,n){if(Bt(t),Bt(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function On(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function Bt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function qn(t,n,e,r){st(t),st(n),Bt(e),n.length>255&&(n=r(D(oe("H2C-OVERSIZE-DST-"),n)));const{outputLen:i,blockLen:o}=r,c=Math.ceil(e/i);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=D(n,ot(n.length,1)),s=ot(0,o),a=ot(e,2),d=new Array(c),l=r(D(s,t,a,ot(0,1),f));d[0]=r(D(l,ot(1,1),f));for(let m=1;m<=c;m++){const _=[On(l,d[m-1]),ot(m+1,1),f];d[m]=r(D(..._))}return D(...d).slice(0,e)}function Nn(t,n,e,r,i){if(st(t),st(n),Bt(e),n.length>255){const o=Math.ceil(2*r/8);n=i.create({dkLen:o}).update(oe("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return i.create({dkLen:e}).update(t).update(ot(e,2)).update(n).update(ot(n.length,1)).digest()}function be(t,n,e){It(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:i,m:o,hash:c,expand:f,DST:s}=e;st(t),Bt(n);const a=typeof s=="string"?oe(s):s,d=r.toString(2).length,l=Math.ceil((d+i)/8),x=n*o*l;let m;if(f==="xmd")m=qn(t,a,x,c);else if(f==="xof")m=Nn(t,a,x,i,c);else if(f==="_internal_pass")m=t;else throw new Error('expand must be "xmd" or "xof"');const _=new Array(n);for(let g=0;g<n;g++){const T=new Array(o);for(let I=0;I<o;I++){const U=l*(I+g*o),y=m.subarray(U,U+l);T[I]=Z(In(y),r)}_[g]=T}return _}function Rn(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,i)=>{const[o,c,f,s]=e.map(l=>l.reduce((x,m)=>t.add(t.mul(x,r),m))),[a,d]=Zt(t,[c,s],!0);return r=t.mul(o,a),i=t.mul(i,t.mul(f,d)),{x:r,y:i}}}function Un(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");function r(o){return t.fromAffine(n(o))}function i(o){const c=o.clearCofactor();return c.equals(t.ZERO)?t.ZERO:(c.assertValidity(),c)}return{defaults:e,hashToCurve(o,c){const f=be(o,2,{...e,DST:e.DST,...c}),s=r(f[0]),a=r(f[1]);return i(s.add(a))},encodeToCurve(o,c){const f=be(o,1,{...e,DST:e.encodeDST,...c});return i(r(f[0]))},mapToCurve(o){if(!Array.isArray(o))throw new Error("expected array of bigints");for(const c of o)if(typeof c!="bigint")throw new Error("expected array of bigints");return i(r(o))}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ot=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Lt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ie=BigInt(0),St=BigInt(1),Tt=BigInt(2),me=(t,n)=>(t+n/Tt)/n;function Ve(t){const n=Ot,e=BigInt(3),r=BigInt(6),i=BigInt(11),o=BigInt(22),c=BigInt(23),f=BigInt(44),s=BigInt(88),a=t*t*t%n,d=a*a*t%n,l=Y(d,e,n)*d%n,x=Y(l,e,n)*d%n,m=Y(x,Tt,n)*a%n,_=Y(m,i,n)*m%n,g=Y(_,o,n)*_%n,T=Y(g,f,n)*g%n,I=Y(T,s,n)*T%n,U=Y(I,f,n)*g%n,y=Y(U,e,n)*d%n,u=Y(y,c,n)*_%n,b=Y(u,r,n)*a%n,p=Y(b,Tt,n);if(!it.eql(it.sqr(p),t))throw new Error("Cannot find square root");return p}const it=se(Ot,void 0,void 0,{sqrt:Ve}),zt=_n({a:ie,b:BigInt(7),Fp:it,n:Lt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Lt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-St*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,c=BigInt("0x100000000000000000000000000000000"),f=me(o*t,n),s=me(-r*t,n);let a=Z(t-f*e-s*i,n),d=Z(-f*r-s*o,n);const l=a>c,x=d>c;if(l&&(a=n-a),x&&(d=n-d),a>c||d>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:a,k2neg:x,k2:d}}}},Ut),ye={};function kt(t,...n){let e=ye[t];if(e===void 0){const r=Ut(Uint8Array.from(t,i=>i.charCodeAt(0)));e=D(r,r),ye[t]=e}return Ut(D(e,...n))}const ce=t=>t.toRawBytes(!0).slice(1),ee=t=>lt(t,32),Xt=t=>Z(t,Ot),At=t=>Z(t,Lt),fe=(()=>zt.ProjectivePoint)(),Hn=(t,n,e)=>fe.BASE.multiplyAndAddUnsafe(t,n,e);function ne(t){let n=zt.utils.normPrivateKeyToScalar(t),e=fe.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:At(-n),bytes:ce(e)}}function Pe(t){ut("x",t,St,Ot);const n=Xt(t*t),e=Xt(n*t+BigInt(7));let r=Ve(e);r%Tt!==ie&&(r=Xt(-r));const i=new fe(t,r,St);return i.assertValidity(),i}const gt=X;function Me(...t){return At(gt(kt("BIP0340/challenge",...t)))}function Ln(t){return ne(t).bytes}function Tn(t,n,e=ve(32)){const r=z("message",t),{bytes:i,scalar:o}=ne(n),c=z("auxRand",e,32),f=ee(o^gt(kt("BIP0340/aux",c))),s=kt("BIP0340/nonce",f,i,r),a=At(gt(s));if(a===ie)throw new Error("sign failed: k is zero");const{bytes:d,scalar:l}=ne(a),x=Me(d,i,r),m=new Uint8Array(64);if(m.set(d,0),m.set(ee(At(l+x*o)),32),!je(m,r,i))throw new Error("sign: Invalid signature produced");return m}function je(t,n,e){const r=z("signature",t,64),i=z("message",n),o=z("publicKey",e,32);try{const c=Pe(gt(o)),f=gt(r.subarray(0,32));if(!vt(f,St,Ot))return!1;const s=gt(r.subarray(32,64));if(!vt(s,St,Lt))return!1;const a=Me(ee(f),ce(c),i),d=Hn(c,s,At(-a));return!(!d||!d.hasEvenY()||d.toAffine().x!==f)}catch{return!1}}const zn=(()=>({getPublicKey:Ln,sign:Tn,verify:je,utils:{randomPrivateKey:zt.utils.randomPrivateKey,lift_x:Pe,pointToBytes:ce,numberToBytesBE:lt,bytesToNumberBE:X,taggedHash:kt,mod:Z}}))(),kn=(()=>Rn(it,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),Cn=(()=>Sn(it,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:it.create(BigInt("-11"))}))(),Ke=(()=>Un(zt.ProjectivePoint,t=>{const{x:n,y:e}=Cn(it.create(t[0]));return kn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:it.ORDER,m:1,k:128,expand:"xmd",hash:Ut}))(),Vn=(()=>Ke.hashToCurve)(),Pn=(()=>Ke.encodeToCurve)();export{Pn as encodeToCurve,Vn as hashToCurve,zn as schnorr,zt as secp256k1,Ke as secp256k1_hasher};
